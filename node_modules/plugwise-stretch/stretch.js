"use strict";

var XML = require('pixl-xml');
var request = require('request');
const EventEmitter = require('events').EventEmitter;

class Stretch extends EventEmitter {

	constructor(password, ip, id, hostname) {
		super();

		// Store properties
		this.password = password;
		this.ip = ip;
		this.id = id;
		this.hostname = hostname;
		this.onoff = undefined;
		this.measure_power = undefined;
		this.meter_power = undefined;
		this.status = undefined;

		// Start polling for data changes
		this._startPolling()
	}

	setState(state, callback) {

		var toggle = (state) ? "on" : "off";

		request({
			url: this._createAPIUrl() + '/relay',
			method: 'PUT',
			body: '<relay><state>' + toggle + '</state></relay>',
			headers: { 'Content-Type': 'text/xml' }
		}, function (error) {
			if (error) {

				console.log("Stretch: set state error: " + error);

				// Emit device unavailable
				if (this.status === 'wait') {
					this.status = 'offline';
					this.emit("unavailable", this);
				} else if (this.status !== 'offline' && typeof this.status !== 'undefined') {

					// Go to wait status
					this.status = 'wait';
				}
			}
			else {

				// Emit device available for first time
				if (typeof this.status === 'undefined') {
					this.status = 'online';
					this.emit('available', this);
				}

				// Emit device available
				if (this.status === 'offline') {
					this.status = 'online';
					this.emit("available", this);
				}

				if (this.status === 'wait') this.status = 'online';

				console.log("Stretch: switch state to " + toggle);

				// Update interval value
				this.onoff = state;

				// Event event that onoff state changed
				this.emit("onoff", state);

				// Return with callback
				callback(null, state);
			}
		}.bind(this));
	};

	_getState(callback) {
		request({ url: this._createAPIUrl(), timeout: 8000, method: 'GET' }, function (error, response, body) {
			if (error) {

				console.log("Stretch: get state error: " + error);

				// Emit device unavailable
				if (this.status === 'wait') {
					this.status = 'offline';
					this.emit("unavailable", this);
				} else if (this.status !== 'offline' && typeof this.status !== 'undefined') {

					// Go to wait status
					this.status = 'wait';
				}

				callback();
			}
			else {

				// Emit device available for first time			
				if (typeof this.status === 'undefined') {
					this.status = 'online';
					this.emit('available', this);
				}

				// Emit device available
				if (this.status === 'offline') {
					this.status = 'online';
					this.emit("available", this);
				}

				if (this.status === 'wait') this.status = 'online';
				
				// Parse XML
				var doc;
				try {
					doc = XML.parse(body);
				} catch (err) {
					return callback(err);
				}
				if (doc && doc.appliance
					&& doc.appliance.actuators
					&& doc.appliance.actuators.relay
					&& doc.appliance.actuators.relay.state) {

					// Convert to boolean
					let state = (doc.appliance.actuators.relay.state === "on");

					// If value changed
					if (this.onoff != state) {
						
						// Emit onoff update event
						this.emit("onoff", state);
					}

					// Update internal value
					this.onoff = state;
					
					// Check if instantanious measured energy is provided
					if (doc.appliance.logs && doc.appliance.logs.point_log) {
						var temp_data = doc.appliance.logs.point_log.filter(function (x) {
							return x.type === 'electricity_consumed'
						})[0];

						if (temp_data && temp_data.period
							&& temp_data.period.measurement
							&& temp_data.period.measurement._Data) {
								
							let measure_power = parseFloat(temp_data.period.measurement._Data)
								
							// If value changed
							if (this.measure_power != measure_power) {

								// Emit measure_power update event
								this.emit("measurepowerchanged", measure_power);
								
								//Update internal energy measure_power
								this.measure_power = measure_power;
							}
						}
					}
					
					// Check if hourly cummulative energy is provided
					if (doc.appliance.logs && doc.appliance.logs.interval_log) {
						var temp_data = doc.appliance.logs.interval_log.filter(function (x) {
							return x.type === 'electricity_consumed'
						})[0];

						if (temp_data && temp_data.period
							&& temp_data.period.measurement
							&& temp_data.period.measurement._Data) {
							
							//meter_power is rounded to 2 decimals to prevent frequent updates	
							let meter_power = Math.round(parseFloat(temp_data.period.measurement._Data)/10) / 100
								
							// If value changed
							if (this.meter_power != meter_power) {

								// Emit meterpower update event
								this.emit("meterpowerchanged", meter_power);
								
								//Update internal meter_power
								this.meter_power = meter_power;
							}
						}
					}
					// Return result
					if (typeof callback == "function") callback(null, state);
				}
				else {

					console.log("Stretch: get state invalid data from plugwise api");

					// Emit device unavailable
					if (this.status === 'wait') {
						this.status = 'offline';
						this.emit("unavailable", this);
					} else if (this.status !== 'offline' && typeof this.status !== 'undefined') {

						// Go to wait status
						this.status = 'wait';
					}

					// Callback error
					if (typeof callback == "function") callback(true, false);
				}

				if (typeof this.onoff === "undefined") this.onoff = false;
			}
		}.bind(this));
	}

	_startPolling() {

		// Fill initial values
		this._getState();

		this.pollInterval = setInterval(() => {

			// Update values
			this._getState();

		}, 15000);
	}

	_createAPIUrl() {
		return `http://stretch:${this.password}@${this.ip}/core/appliances/${this.id}`;
	}

	remove() {
		if (this.pollInterval) clearInterval(this.pollInterval);
	}
}

module.exports = Stretch;