"use strict";

var XML = require('pixl-xml');
var request = require('request');
const EventEmitter = require('events').EventEmitter;

class Stretch extends EventEmitter {

	constructor(password, ip, id, hostname) {
		super();

		// Store properties
		this.password = password;
		this.ip = ip;
		this.id = id;
		this.hostname = hostname;
		this.onoff = false;
		this.status = false;

		// Start polling for data changes
		this._startPolling()
	}

	setState(state, callback) {

		var toggle = (state) ? "on" : "off";

		request({
			url: this._createAPIUrl() + '/relay',
			method: 'PUT',
			body: '<relay><state>' + toggle + '</state></relay>',
			headers: {'Content-Type': 'text/xml'}
		}, function (error) {
			if (error) {

				// Emit device unavailable
				if (this.status) {
					this.emit("unavailable", this);
					this.status = false;
				}
			}
			else {

				// Update interval value
				this.onoff = state;

				// Event event that onoff state changed
				this.emit("onoff", state);

				// Return with callback
				callback(null, state);
			}
		}.bind(this));
	};

	_getState(callback) {
		request({url: this._createAPIUrl(), timeout: 2000, method: 'GET'}, function (error, response, body) {
			if (error) {
				console.log(error);
				// Emit device unavailable
				if (this.status) {
					this.emit("unavailable", this);
					this.status = false;
				}
			}
			else {

				// Emit device available
				if (!this.status) {
					this.emit("available", this);
					this.status = true;
				}

				// Fetch data from XML
				var doc = XML.parse(body);
				if (doc && doc.appliance
					&& doc.appliance.actuators
					&& doc.appliance.actuators.relay
					&& doc.appliance.actuators.relay.state) {
					
					console.log("got all variables");
					console.log("state: " + doc.appliance.actuators.relay.state);
					console.log(doc.appliance.actuators.relay);

					// Convert to boolean
					let state = (doc.appliance.actuators.relay.state === "on");

					// If value changed
					if (this.onoff != state) {

						// Emit onoff update event
						this.emit("onoff", state);
					}

					// Update internal value
					this.onoff = state;

					// Return result
					if (typeof callback == "function") callback(null, state);
				}
				else {
					
					console.log("else after parsing")

					// Callback error
					if (typeof callback == "function") callback(true, false);
				}
			}
		}.bind(this));
	}

	_startPolling() {

		// Fill initial values
		this._getState();

		setInterval(() => {

			// Update values
			this._getState();

		}, 15000);
	}

	_createAPIUrl() {
		return `http://stretch:${this.password}@${this.ip}/core/appliances/${this.id}`;
	}
}

module.exports = Stretch;